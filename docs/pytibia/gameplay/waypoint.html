<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pytibia.gameplay.waypoint API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pytibia.gameplay.waypoint</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pyautogui
import tcod
import time
import hud.core
import hud.slot
import radar.config
import radar.core
import radar.extractors
import utils.array
import utils.coordinate
import utils.core
import utils.image
import utils.mouse
import utils.matrix


# TODO: add unit tests
def generateFloorWalkpoints(coordinate, goalCoordinate):
    pixelCoordinate = utils.core.getPixelFromCoordinate(coordinate)
    xFromTheStartOfRadar = pixelCoordinate[0] - 53
    xFromTheEndOfRadar = pixelCoordinate[0] + 53
    yFromTheStartOfRadar = pixelCoordinate[1] - 54
    yFromTheEndOfRadar = pixelCoordinate[1] + 55
    xOfRadarCoordinate, yOfRadarCoordinate, level = coordinate
    walkableFloorsSqms = radar.config.walkableFloorsSqms[level].copy()
    walkableFloorsSqms = walkableFloorsSqms[
        yFromTheStartOfRadar:yFromTheEndOfRadar, xFromTheStartOfRadar:xFromTheEndOfRadar]
    # TODO: colocar os players, monstros e buracos/escadas
    pf = tcod.path.AStar(walkableFloorsSqms, 0)
    xOfGoalCoordinate, yOfGoalCoordinate, _ = goalCoordinate
    x = xOfGoalCoordinate - xOfRadarCoordinate + 53
    y = yOfGoalCoordinate - yOfRadarCoordinate + 54
    paths = pf.get_path(54, 53, y, x)
    walkpoints = [[xOfRadarCoordinate + x - 53,
                   yOfRadarCoordinate + y - 54, level] for y, x in paths]
    return walkpoints


# TODO: add unit tests
def resolveFloorCoordinate(_, nextCoordinate):
    return nextCoordinate


# TODO: add unit tests
def resolveMoveUpCoordinate(_, nextCoordinate):
    return nextCoordinate


# TODO: add unit tests
def resolveShovelWaypointCoordinate(radarCoordinate, nextCoordinate):
    floorLevel = nextCoordinate[2]
    walkableFloorSqms = radar.config.walkableFloorsSqms[floorLevel].copy()
    availableAroundCoordinates = utils.coordinate.getAvailableAroundCoordinates(
        nextCoordinate, walkableFloorSqms)
    closestCoordinate = utils.coordinate.getClosestCoordinate(
        radarCoordinate, availableAroundCoordinates)
    return closestCoordinate


# TODO: add unit tests
def resolveGoalCoordinate(radarCoordinate, waypoint):
    goalCoordinate = None
    if waypoint[&#39;type&#39;] == &#39;shovel&#39;:
        goalCoordinate = resolveShovelWaypointCoordinate(
            radarCoordinate, waypoint[&#39;coordinate&#39;])
    elif waypoint[&#39;type&#39;] == &#39;moveUp&#39;:
        goalCoordinate = resolveMoveUpCoordinate(
            radarCoordinate, waypoint[&#39;coordinate&#39;])
    else:
        goalCoordinate = resolveFloorCoordinate(
            radarCoordinate, waypoint[&#39;coordinate&#39;])
    return goalCoordinate


# TODO: add unit tests
def resolveWaypointByType(screenshot, radarCoordinate, waypointsManager):
    copiedWaypointsManager = waypointsManager.copy()
    hasReachedGoalCoordinate = np.all(
        radarCoordinate == copiedWaypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;])
    if copiedWaypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;type&#39;] == &#39;shovel&#39;:
        if copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] == &#39;awaiting&#39;:
            if hasReachedGoalCoordinate:
                copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] = &#39;isInCoordinate&#39;
                # TODO: send command to sleep 2secs in next frame
                time.sleep(2)
        elif copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] == &#39;isInCoordinate&#39;:
            slot = hud.core.getSlotFromCoordinate(
                radarCoordinate, waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;coordinate&#39;])
            hudCoordinate = hud.core.getCoordinate(screenshot)
            hudImg = hud.core.getImgByCoordinate(screenshot, hudCoordinate)
            slotImg = hud.core.getSlotImg(hudImg, slot)
            if hud.core.isHoleOpen(slotImg):
                copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] = &#39;goingToHole&#39;
                newGoalCoordinate = copiedWaypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;coordinate&#39;]
                newGoalCoordinate[2] = newGoalCoordinate[2] - 1
                copiedWaypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;] = newGoalCoordinate
            else:
                pyautogui.press(&#39;f9&#39;)
                hudCoordinate = hud.core.getCoordinate(screenshot)
                slot = hud.core.getSlotFromCoordinate(
                    radarCoordinate, waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;coordinate&#39;])
                hud.slot.clickSlot(slot, hudCoordinate)
    else:
        if hasReachedGoalCoordinate:
            copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] = &#39;done&#39;
    return copiedWaypointsManager


# TODO: add unit tests
def handleWaypoint(screenshot, radarCoordinate, waypointsManager):
    copiedWaypointsManager = waypointsManager.copy()
    nextWaypointIndex = utils.array.getNextArrayIndex(
        copiedWaypointsManager[&#39;points&#39;], copiedWaypointsManager[&#39;currentIndex&#39;])
    nextWaypoint = copiedWaypointsManager[&#39;points&#39;][nextWaypointIndex]
    if copiedWaypointsManager[&#39;state&#39;] == None:
        copiedWaypointsManager[&#39;state&#39;] = {
            &#39;goalCoordinate&#39;: resolveGoalCoordinate(radarCoordinate, nextWaypoint),
            &#39;goalWaypoint&#39;: nextWaypoint,
            &#39;status&#39;: &#39;awaiting&#39;
        }
    copiedWaypointsManager = resolveWaypointByType(
        screenshot, radarCoordinate, copiedWaypointsManager)
    hasWaypointResolved = copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] == &#39;done&#39;
    if hasWaypointResolved:
        copiedWaypointsManager[&#39;currentIndex&#39;] = nextWaypointIndex
        nextOfNextWaypointIndex = utils.array.getNextArrayIndex(
            copiedWaypointsManager[&#39;points&#39;], copiedWaypointsManager[&#39;currentIndex&#39;])
        nextWaypoint = copiedWaypointsManager[&#39;points&#39;][nextOfNextWaypointIndex]
        copiedWaypointsManager[&#39;state&#39;] = {
            &#39;goalCoordinate&#39;: resolveGoalCoordinate(radarCoordinate, nextWaypoint),
            &#39;goalWaypoint&#39;: nextWaypoint,
            &#39;status&#39;: &#39;awaiting&#39;
        }
    return copiedWaypointsManager


# TODO: add unit tests
# TODO: if path is blocked by player, npc, or another block object, maybe reset the path
# TODO: if char doesnt move for some time, maybe reset the path
# TODO: reset path when paralyzed
def handleWalkpoints(radarCoordinate, walkpointsManager, waypointsManager):
    copiedWalkpointsManager = walkpointsManager.copy()
    shouldRecalculateWalkpoints = len(
        copiedWalkpointsManager[&#39;points&#39;]) == 0
    if shouldRecalculateWalkpoints:
        copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = None
        if waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;type&#39;] == &#39;moveUp&#39;:
            copiedWalkpointsManager[&#39;points&#39;] = np.array(
                [waypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;]])
        elif waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;type&#39;] == &#39;moveDown&#39;:
            copiedWalkpointsManager[&#39;points&#39;] = np.array(
                [waypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;]])
        else:
            copiedWalkpointsManager[&#39;points&#39;] = generateFloorWalkpoints(
                radarCoordinate, waypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;])
    return copiedWalkpointsManager


# TODO: add unit tests
# TODO: if character is walking in a non path, maybe reset the path
def walk(radarCoordinate, walkpointsManager):
    copiedWalkpointsManager = walkpointsManager.copy()
    shouldntWalk = len(copiedWalkpointsManager[&#39;points&#39;]) == 0
    if shouldntWalk:
        if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
            pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
            copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
        copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = None
        copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] = None
        return copiedWalkpointsManager
    nextWalkpointIndex = 0
    coordinateDidntChange = np.all(
        radarCoordinate == copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;])
    if coordinateDidntChange:
        if copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] is None:
            return copiedWalkpointsManager
        charSpeed = 2250
        tileFriction = radar.core.getTileFrictionByRadarCoordinate(
            copiedWalkpointsManager[&#39;points&#39;][nextWalkpointIndex])
        movementSpeed = radar.core.getBreakpointTileMovementSpeed(
            charSpeed, tileFriction)
        currentTime = time.time()
        timeSinceLastCoordinateVisitedAt = (currentTime -
                                            copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;]) * 1000
        movementSpeedDot3 = movementSpeed * 3
        shouldResetPath = timeSinceLastCoordinateVisitedAt &gt; movementSpeedDot3
        if shouldResetPath:
            copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = None
            copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] = None
            copiedWalkpointsManager[&#39;points&#39;] = np.array([])
            if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
                pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
                copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
        return copiedWalkpointsManager
    copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = radarCoordinate
    copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] = time.time()
    nextWalkpointRadarCoordinate = copiedWalkpointsManager[&#39;points&#39;][nextWalkpointIndex]
    direction = utils.coordinate.getDirectionBetweenRadarCoordinates(
        radarCoordinate, nextWalkpointRadarCoordinate)
    beingDeletedWalkpoint = copiedWalkpointsManager[&#39;points&#39;][0].copy()
    copiedWalkpointsManager[&#39;points&#39;] = np.delete(
        copiedWalkpointsManager[&#39;points&#39;], 0, axis=0)
    hasNoNewDirection = direction is None
    if hasNoNewDirection:
        return copiedWalkpointsManager
    if len(copiedWalkpointsManager[&#39;points&#39;]) &gt; 0:
        futureDirection = utils.coordinate.getDirectionBetweenRadarCoordinates(
            beingDeletedWalkpoint, copiedWalkpointsManager[&#39;points&#39;][0])
    else:
        futureDirection = None
    if direction != futureDirection:
        if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
            pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
            copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
        else:
            pyautogui.press(direction)
        return copiedWalkpointsManager
    else:
        pointsLength = len(copiedWalkpointsManager[&#39;points&#39;])
        if direction != copiedWalkpointsManager[&#39;lastPressedKey&#39;]:
            if pointsLength &gt; 2:
                pyautogui.keyDown(direction)
                copiedWalkpointsManager[&#39;lastPressedKey&#39;] = direction
            else:
                pyautogui.press(direction)
        elif pointsLength == 1:
            if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
                pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
                copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
    return copiedWalkpointsManager</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pytibia.gameplay.waypoint.generateFloorWalkpoints"><code class="name flex">
<span>def <span class="ident">generateFloorWalkpoints</span></span>(<span>coordinate, goalCoordinate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateFloorWalkpoints(coordinate, goalCoordinate):
    pixelCoordinate = utils.core.getPixelFromCoordinate(coordinate)
    xFromTheStartOfRadar = pixelCoordinate[0] - 53
    xFromTheEndOfRadar = pixelCoordinate[0] + 53
    yFromTheStartOfRadar = pixelCoordinate[1] - 54
    yFromTheEndOfRadar = pixelCoordinate[1] + 55
    xOfRadarCoordinate, yOfRadarCoordinate, level = coordinate
    walkableFloorsSqms = radar.config.walkableFloorsSqms[level].copy()
    walkableFloorsSqms = walkableFloorsSqms[
        yFromTheStartOfRadar:yFromTheEndOfRadar, xFromTheStartOfRadar:xFromTheEndOfRadar]
    # TODO: colocar os players, monstros e buracos/escadas
    pf = tcod.path.AStar(walkableFloorsSqms, 0)
    xOfGoalCoordinate, yOfGoalCoordinate, _ = goalCoordinate
    x = xOfGoalCoordinate - xOfRadarCoordinate + 53
    y = yOfGoalCoordinate - yOfRadarCoordinate + 54
    paths = pf.get_path(54, 53, y, x)
    walkpoints = [[xOfRadarCoordinate + x - 53,
                   yOfRadarCoordinate + y - 54, level] for y, x in paths]
    return walkpoints</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.handleWalkpoints"><code class="name flex">
<span>def <span class="ident">handleWalkpoints</span></span>(<span>radarCoordinate, walkpointsManager, waypointsManager)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleWalkpoints(radarCoordinate, walkpointsManager, waypointsManager):
    copiedWalkpointsManager = walkpointsManager.copy()
    shouldRecalculateWalkpoints = len(
        copiedWalkpointsManager[&#39;points&#39;]) == 0
    if shouldRecalculateWalkpoints:
        copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = None
        if waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;type&#39;] == &#39;moveUp&#39;:
            copiedWalkpointsManager[&#39;points&#39;] = np.array(
                [waypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;]])
        elif waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;type&#39;] == &#39;moveDown&#39;:
            copiedWalkpointsManager[&#39;points&#39;] = np.array(
                [waypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;]])
        else:
            copiedWalkpointsManager[&#39;points&#39;] = generateFloorWalkpoints(
                radarCoordinate, waypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;])
    return copiedWalkpointsManager</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.handleWaypoint"><code class="name flex">
<span>def <span class="ident">handleWaypoint</span></span>(<span>screenshot, radarCoordinate, waypointsManager)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleWaypoint(screenshot, radarCoordinate, waypointsManager):
    copiedWaypointsManager = waypointsManager.copy()
    nextWaypointIndex = utils.array.getNextArrayIndex(
        copiedWaypointsManager[&#39;points&#39;], copiedWaypointsManager[&#39;currentIndex&#39;])
    nextWaypoint = copiedWaypointsManager[&#39;points&#39;][nextWaypointIndex]
    if copiedWaypointsManager[&#39;state&#39;] == None:
        copiedWaypointsManager[&#39;state&#39;] = {
            &#39;goalCoordinate&#39;: resolveGoalCoordinate(radarCoordinate, nextWaypoint),
            &#39;goalWaypoint&#39;: nextWaypoint,
            &#39;status&#39;: &#39;awaiting&#39;
        }
    copiedWaypointsManager = resolveWaypointByType(
        screenshot, radarCoordinate, copiedWaypointsManager)
    hasWaypointResolved = copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] == &#39;done&#39;
    if hasWaypointResolved:
        copiedWaypointsManager[&#39;currentIndex&#39;] = nextWaypointIndex
        nextOfNextWaypointIndex = utils.array.getNextArrayIndex(
            copiedWaypointsManager[&#39;points&#39;], copiedWaypointsManager[&#39;currentIndex&#39;])
        nextWaypoint = copiedWaypointsManager[&#39;points&#39;][nextOfNextWaypointIndex]
        copiedWaypointsManager[&#39;state&#39;] = {
            &#39;goalCoordinate&#39;: resolveGoalCoordinate(radarCoordinate, nextWaypoint),
            &#39;goalWaypoint&#39;: nextWaypoint,
            &#39;status&#39;: &#39;awaiting&#39;
        }
    return copiedWaypointsManager</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.resolveFloorCoordinate"><code class="name flex">
<span>def <span class="ident">resolveFloorCoordinate</span></span>(<span>_, nextCoordinate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolveFloorCoordinate(_, nextCoordinate):
    return nextCoordinate</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.resolveGoalCoordinate"><code class="name flex">
<span>def <span class="ident">resolveGoalCoordinate</span></span>(<span>radarCoordinate, waypoint)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolveGoalCoordinate(radarCoordinate, waypoint):
    goalCoordinate = None
    if waypoint[&#39;type&#39;] == &#39;shovel&#39;:
        goalCoordinate = resolveShovelWaypointCoordinate(
            radarCoordinate, waypoint[&#39;coordinate&#39;])
    elif waypoint[&#39;type&#39;] == &#39;moveUp&#39;:
        goalCoordinate = resolveMoveUpCoordinate(
            radarCoordinate, waypoint[&#39;coordinate&#39;])
    else:
        goalCoordinate = resolveFloorCoordinate(
            radarCoordinate, waypoint[&#39;coordinate&#39;])
    return goalCoordinate</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.resolveMoveUpCoordinate"><code class="name flex">
<span>def <span class="ident">resolveMoveUpCoordinate</span></span>(<span>_, nextCoordinate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolveMoveUpCoordinate(_, nextCoordinate):
    return nextCoordinate</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.resolveShovelWaypointCoordinate"><code class="name flex">
<span>def <span class="ident">resolveShovelWaypointCoordinate</span></span>(<span>radarCoordinate, nextCoordinate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolveShovelWaypointCoordinate(radarCoordinate, nextCoordinate):
    floorLevel = nextCoordinate[2]
    walkableFloorSqms = radar.config.walkableFloorsSqms[floorLevel].copy()
    availableAroundCoordinates = utils.coordinate.getAvailableAroundCoordinates(
        nextCoordinate, walkableFloorSqms)
    closestCoordinate = utils.coordinate.getClosestCoordinate(
        radarCoordinate, availableAroundCoordinates)
    return closestCoordinate</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.resolveWaypointByType"><code class="name flex">
<span>def <span class="ident">resolveWaypointByType</span></span>(<span>screenshot, radarCoordinate, waypointsManager)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolveWaypointByType(screenshot, radarCoordinate, waypointsManager):
    copiedWaypointsManager = waypointsManager.copy()
    hasReachedGoalCoordinate = np.all(
        radarCoordinate == copiedWaypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;])
    if copiedWaypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;type&#39;] == &#39;shovel&#39;:
        if copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] == &#39;awaiting&#39;:
            if hasReachedGoalCoordinate:
                copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] = &#39;isInCoordinate&#39;
                # TODO: send command to sleep 2secs in next frame
                time.sleep(2)
        elif copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] == &#39;isInCoordinate&#39;:
            slot = hud.core.getSlotFromCoordinate(
                radarCoordinate, waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;coordinate&#39;])
            hudCoordinate = hud.core.getCoordinate(screenshot)
            hudImg = hud.core.getImgByCoordinate(screenshot, hudCoordinate)
            slotImg = hud.core.getSlotImg(hudImg, slot)
            if hud.core.isHoleOpen(slotImg):
                copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] = &#39;goingToHole&#39;
                newGoalCoordinate = copiedWaypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;coordinate&#39;]
                newGoalCoordinate[2] = newGoalCoordinate[2] - 1
                copiedWaypointsManager[&#39;state&#39;][&#39;goalCoordinate&#39;] = newGoalCoordinate
            else:
                pyautogui.press(&#39;f9&#39;)
                hudCoordinate = hud.core.getCoordinate(screenshot)
                slot = hud.core.getSlotFromCoordinate(
                    radarCoordinate, waypointsManager[&#39;state&#39;][&#39;goalWaypoint&#39;][&#39;coordinate&#39;])
                hud.slot.clickSlot(slot, hudCoordinate)
    else:
        if hasReachedGoalCoordinate:
            copiedWaypointsManager[&#39;state&#39;][&#39;status&#39;] = &#39;done&#39;
    return copiedWaypointsManager</code></pre>
</details>
</dd>
<dt id="pytibia.gameplay.waypoint.walk"><code class="name flex">
<span>def <span class="ident">walk</span></span>(<span>radarCoordinate, walkpointsManager)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk(radarCoordinate, walkpointsManager):
    copiedWalkpointsManager = walkpointsManager.copy()
    shouldntWalk = len(copiedWalkpointsManager[&#39;points&#39;]) == 0
    if shouldntWalk:
        if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
            pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
            copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
        copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = None
        copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] = None
        return copiedWalkpointsManager
    nextWalkpointIndex = 0
    coordinateDidntChange = np.all(
        radarCoordinate == copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;])
    if coordinateDidntChange:
        if copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] is None:
            return copiedWalkpointsManager
        charSpeed = 2250
        tileFriction = radar.core.getTileFrictionByRadarCoordinate(
            copiedWalkpointsManager[&#39;points&#39;][nextWalkpointIndex])
        movementSpeed = radar.core.getBreakpointTileMovementSpeed(
            charSpeed, tileFriction)
        currentTime = time.time()
        timeSinceLastCoordinateVisitedAt = (currentTime -
                                            copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;]) * 1000
        movementSpeedDot3 = movementSpeed * 3
        shouldResetPath = timeSinceLastCoordinateVisitedAt &gt; movementSpeedDot3
        if shouldResetPath:
            copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = None
            copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] = None
            copiedWalkpointsManager[&#39;points&#39;] = np.array([])
            if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
                pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
                copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
        return copiedWalkpointsManager
    copiedWalkpointsManager[&#39;lastCoordinateVisited&#39;] = radarCoordinate
    copiedWalkpointsManager[&#39;lastCoordinateVisitedAt&#39;] = time.time()
    nextWalkpointRadarCoordinate = copiedWalkpointsManager[&#39;points&#39;][nextWalkpointIndex]
    direction = utils.coordinate.getDirectionBetweenRadarCoordinates(
        radarCoordinate, nextWalkpointRadarCoordinate)
    beingDeletedWalkpoint = copiedWalkpointsManager[&#39;points&#39;][0].copy()
    copiedWalkpointsManager[&#39;points&#39;] = np.delete(
        copiedWalkpointsManager[&#39;points&#39;], 0, axis=0)
    hasNoNewDirection = direction is None
    if hasNoNewDirection:
        return copiedWalkpointsManager
    if len(copiedWalkpointsManager[&#39;points&#39;]) &gt; 0:
        futureDirection = utils.coordinate.getDirectionBetweenRadarCoordinates(
            beingDeletedWalkpoint, copiedWalkpointsManager[&#39;points&#39;][0])
    else:
        futureDirection = None
    if direction != futureDirection:
        if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
            pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
            copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
        else:
            pyautogui.press(direction)
        return copiedWalkpointsManager
    else:
        pointsLength = len(copiedWalkpointsManager[&#39;points&#39;])
        if direction != copiedWalkpointsManager[&#39;lastPressedKey&#39;]:
            if pointsLength &gt; 2:
                pyautogui.keyDown(direction)
                copiedWalkpointsManager[&#39;lastPressedKey&#39;] = direction
            else:
                pyautogui.press(direction)
        elif pointsLength == 1:
            if copiedWalkpointsManager[&#39;lastPressedKey&#39;] is not None:
                pyautogui.keyUp(copiedWalkpointsManager[&#39;lastPressedKey&#39;])
                copiedWalkpointsManager[&#39;lastPressedKey&#39;] = None
    return copiedWalkpointsManager</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pytibia.gameplay" href="index.html">pytibia.gameplay</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pytibia.gameplay.waypoint.generateFloorWalkpoints" href="#pytibia.gameplay.waypoint.generateFloorWalkpoints">generateFloorWalkpoints</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.handleWalkpoints" href="#pytibia.gameplay.waypoint.handleWalkpoints">handleWalkpoints</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.handleWaypoint" href="#pytibia.gameplay.waypoint.handleWaypoint">handleWaypoint</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.resolveFloorCoordinate" href="#pytibia.gameplay.waypoint.resolveFloorCoordinate">resolveFloorCoordinate</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.resolveGoalCoordinate" href="#pytibia.gameplay.waypoint.resolveGoalCoordinate">resolveGoalCoordinate</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.resolveMoveUpCoordinate" href="#pytibia.gameplay.waypoint.resolveMoveUpCoordinate">resolveMoveUpCoordinate</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.resolveShovelWaypointCoordinate" href="#pytibia.gameplay.waypoint.resolveShovelWaypointCoordinate">resolveShovelWaypointCoordinate</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.resolveWaypointByType" href="#pytibia.gameplay.waypoint.resolveWaypointByType">resolveWaypointByType</a></code></li>
<li><code><a title="pytibia.gameplay.waypoint.walk" href="#pytibia.gameplay.waypoint.walk">walk</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>